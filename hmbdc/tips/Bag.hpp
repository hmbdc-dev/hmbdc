#pragma once
#include "hmbdc/time/Time.hpp"
#include "hmbdc/app/Config.hpp"
#include "hmbdc/app/Message.hpp"
#include <iostream>
#include <fstream>
#include <atomic>
#include <future>
#include <sstream>
#include <unordered_map>

/**
 * @brief a bag is a file that contains a sequence of timestamped TIPS messages
 * It is normally generated by the tips console tool, and it can be played back to a domain
 * via the tips console tool.
 * It is also possible to write customized tools to consume and record bags using 
 * the OutputBag and InputBag classes below
 * Check out its usage in tips console source code
 * 
 */
namespace hmbdc { namespace tips {
/**
 * @brief presented at the beginning of a bag 
 * Following the BagHead there is a json text for the config to describe the bag
 * 
 */
struct BagHead {
    time::SysTime createdTs;
    size_t cfgLen{0};

    friend
    std::ostream& operator << (std::ostream& os, BagHead const& h) {
        return os.write((char const*)&h, sizeof(h));
    }
    friend
    std::istream& operator >> (std::istream& is, BagHead& h) {
        return is.read((char*)&h, sizeof(h));
    }
};

/**
 * @brief presented at the beginning of a message record in a bag
 * 
 */
struct BagMessageHead {
    time::SysTime createdTs;
    size_t attLen{0};
    uint16_t tag{0};
    uint16_t reserved{0};
    uint32_t reserved2{0};

    friend
    std::ostream& operator << (std::ostream& os, BagMessageHead const& h) {
        return os.write((char const*)&h, sizeof(h));
    }
    friend
    std::istream& operator >> (std::istream& is, BagMessageHead& h) {
        return is.read((char*)&h, sizeof(h));
    }
};

/**
 * @brief a bag for output / record purpose
 * 
 */
struct OutputBag {
    /**
     * @brief Construct a new Output Bag object
     * 
     * @param file path to the output file
     * @param config the config (contains bufWidth) used to generate the bag
     */
    OutputBag(char const* file, app::Config const& config)
    : bufWidth_(config.getExt<size_t>("bufWidth"))
    , recordBag_(file, std::ofstream::out | std::ios::binary) {
        std::ostringstream oss; 
        boost::property_tree::write_json(oss, config);
        auto cfgText = oss.str();
        size_t l = cfgText.size();
        BagHead bh{time::SysTime::now(), l};
        recordBag_ << bh;
        recordBag_.write(cfgText.c_str(), cfgText.size());
    }

    /**
     * @brief the bufWidth
     * 
     * @return size_t 
     */
    size_t bufWidth() const {
        return bufWidth_;
    }

    /**
     * @brief record a message into the bag
     * 
     * @param tag message tag
     * @param bytes message bytes - the buffer should be matching bufWidth in Config
     * @param att attachment 
     */
    void record(uint16_t tag, uint8_t const* bytes, app::hasMemoryAttachment* att) {
        BagMessageHead bh{time::SysTime::now(), att?att->len:0xfffffffffffffffful, tag};
        recordBag_ << bh;
        recordBag_.write((char const*)bytes, bufWidth_);
        if (att) {
            recordBag_.write((char*)att->attachment, att->len);
        }
        recordBagStats_[tag]++;
    }

    /**
     * @brief check the status of the bag
     * 
     * @return true - everything is fine can record more
     * @return false - not valid bag object
     */
    operator bool() const {
        return (bool)recordBag_;
    }

    /**
     * @brief a map from tag to counts in the bag
     * 
     * @return auto& the map
     */
    auto& stats() const {
        return recordBagStats_;
    }

    /**
     * @brief dump t he above int a stream
     * 
     * @param os output stream
     */
    void dumpStats(std::ostream& os) const {
        for (auto const& [tag, count] : stats()) {
            os << tag << " : " << count << std::endl;
        }
    }


    /**
     * @brief close the bag file
     * 
     */
    void close() {
        recordBag_.close();
    }

private:
    size_t bufWidth_;
    std::ofstream recordBag_;
    std::unordered_map<uint16_t, size_t> recordBagStats_;
};

/**
 * @brief A read / playable bag
 * 
 */
struct InputBag {
    std::optional<std::unordered_set<int16_t>> const runtimeFilterinTags;
    std::optional<std::pair<time::SysTime, time::Duration>> const bagPlayRange; /// passed in

    /**
     * @brief Construct a new Input Bag object
     * 
     * @param file the bag file
     * @param runtimeFilterinTags an optional tag filering hash set
     * @param bagPlayRange an optional pair specifying the time range in the bag to play in the simulation
     * 
     */
    InputBag(char const* file
        , std::optional<std::unordered_set<int16_t>> const& runtimeFilterinTags = std::nullopt
        , std::optional<std::pair<time::SysTime, time::Duration>> bagPlayRange = std::nullopt)
    : runtimeFilterinTags{runtimeFilterinTags}
    , bagPlayRange{bagPlayRange} 
    , playBag_(file, std::ofstream::in | std::ios::binary) {
        playBag_ >> bh_;
        std::ostringstream oss;
        char conf[bh_.cfgLen + 1];
        playBag_.read(conf, bh_.cfgLen);
        conf[bh_.cfgLen] = 0;
        config_ = app::Config(conf);
        bufWidth_ = config_.getExt<size_t>("bufWidth");
    }

    /**
     * @brief get the Bag Head
     * 
     * @return BagHead const& 
     */
    BagHead const& bagHead() const {
        return bh_;
    }

    /**
     * @brief get the config of this bag
     * 
     * @return app::Config const&
     */
    app::Config const& config() const {
        return config_;
    }

    /**
     * @brief the bufWidth
     * 
     * @return size_t 
     */
    size_t bufWidth() const {
        return bufWidth_;
    }

    /**
     * @brief bag object status
     * 
     * @return true - can play more
     * @return false 
     */
    operator bool() const {
        return (bool)playBag_;
    }

    /**
     * @brief check end of bag reached
     * 
     * @return true 
     * @return false 
     */
    bool eof() const {
        return playBag_.eof();
    }

    /**
     * @brief play a message into user provided buffer
     * 
     * @param tag output tag
     * @param bytes message bytes - its size >= bufWidth
     * @param att the attachment coming with the message, attachment memory is not allocated 
     * by the user. Its is allocated by this func
     * @return BagMessageHead - it also contains the tag and other info
     */
    BagMessageHead play(uint16_t& tag, uint8_t* bytes, app::hasMemoryAttachment*& att) {
        auto playOk = false;
        BagMessageHead bmh;
        while(!playOk) {
            playBag_ >> bmh;
            if (!playBag_ || 
                (bagPlayRange && bmh.createdTs >= bagPlayRange->first + bagPlayRange->second)) {
                break;
            }
            if ((!runtimeFilterinTags || runtimeFilterinTags->count(bmh.tag))
                && (!bagPlayRange || bmh.createdTs >= bagPlayRange->first)) {
                tag = bmh.tag;
                if (!playBag_.read((char*)bytes, bufWidth_)) {
                    break;
                }
                if (bmh.attLen != 0xfffffffffffffffful) {
                    att = new (bytes) app::hasMemoryAttachment;
                    att->len = bmh.attLen;
                    att->attachment = malloc(sizeof(size_t) + att->len);
                    auto& refCount = *(size_t*)att->attachment;
                    refCount = 1;
                    att->clientData[0] = (uint64_t)&refCount;
                    att->attachment = (char*)att->attachment + sizeof(size_t);
                    att->afterConsumedCleanupFunc = [](app::hasMemoryAttachment* att) {
                        auto& refCount = *((size_t*)att->clientData[0]);
                        if (0 == --*reinterpret_cast<std::atomic<size_t>*>(&refCount)) {
                            auto toFree = (char*)att->attachment;
                            toFree -= sizeof(size_t);
                            ::free(toFree);
                        }
                    };

                    if (!playBag_.read((char*)att->attachment, att->len)) {
                        att->release();
                        playBag_.close();
                        break;
                    }
                } else {
                    att = nullptr;
                }
                playOk = true; // only place for playOk true
            } else {
                playBag_.seekg(bufWidth_, std::ios::cur);
                if (bmh.attLen != 0xfffffffffffffffful) {
                    playBag_.seekg(bmh.attLen, std::ios::cur);
                }
            }
        };
        if (!playOk) {
            playBag_.close();
            bmh = BagMessageHead{};
        }
        return bmh;
    }

    /**
     * @brief close the file
     * 
     */
    void close() {
        playBag_.close();
    }

private:
    BagHead bh_; 
    size_t bufWidth_{0};
    std::ifstream playBag_;
    app::Config config_;
};

}}
